Perfect. Wave J.1 is now formally authorized.

Below is the tight, production-grade Replit execution prompt for Wave J.1 ‚Äî Unified Order Abstraction, written to be unambiguous, non-creative, and governance-safe.

‚∏ª

üîß REPLIT EXECUTION PROMPT

WAVE J.1 ‚Äî UNIFIED ORDER ABSTRACTION (READ-ONLY)

CONTEXT

WebWaka currently has three separate order domains:
	‚Ä¢	SVM (svm_orders, svm_order_items)
	‚Ä¢	MVM (mvm_parent_order, mvm_sub_order, mvm_parent_order_item)
	‚Ä¢	ParkHub (park_ticket)

These schemas are correct and must NOT be modified.
However, the lack of a canonical abstraction blocks:
	‚Ä¢	Unified customer order views
	‚Ä¢	Receipt linking
	‚Ä¢	Notifications
	‚Ä¢	Analytics
	‚Ä¢	Mobile app readiness

This wave introduces a READ-ONLY canonical order abstraction layer that wraps existing data without changing it.

‚∏ª

üéØ WAVE J.1 OBJECTIVE

Create a Canonical Order Layer that:
	‚Ä¢	Normalizes SVM, MVM, and ParkHub orders into a single interface
	‚Ä¢	Is read-only
	‚Ä¢	Introduces NO new business logic
	‚Ä¢	Introduces NO schema changes
	‚Ä¢	Introduces NO mutations
	‚Ä¢	Is safe for demo and live tenants

‚∏ª

üö´ HARD CONSTRAINTS (NON-NEGOTIABLE)

Replit MUST NOT:
	‚Ä¢	‚ùå Add or modify Prisma models
	‚Ä¢	‚ùå Add migrations
	‚Ä¢	‚ùå Change existing order creation logic
	‚Ä¢	‚ùå Change order status logic
	‚Ä¢	‚ùå Add payments, refunds, or notifications
	‚Ä¢	‚ùå Add background jobs or automation
	‚Ä¢	‚ùå ‚ÄúFix‚Äù inconsistencies in existing schemas

Replit MAY ONLY:
	‚Ä¢	‚úÖ Read from existing tables
	‚Ä¢	‚úÖ Map data into a new canonical interface
	‚Ä¢	‚úÖ Add new TypeScript files/services
	‚Ä¢	‚úÖ Add new read-only API endpoints
	‚Ä¢	‚úÖ Add documentation of gaps

‚∏ª

üì¶ DELIVERABLES

1Ô∏è‚É£ Canonical Interfaces (Code Only)

Create a new folder:

frontend/src/lib/commerce/canonical-order/

CanonicalOrder interface

export interface CanonicalOrder {
  id: string
  tenantId: string
  type: 'SVM' | 'MVM' | 'PARKHUB'
  reference: string
  status: CanonicalOrderStatus
  amount: {
    subtotal: number
    total: number
    currency: 'NGN'
  }
  items: CanonicalOrderItem[]
  customer: CanonicalCustomer
  createdAt: Date
  sourceId: string
  metadata: Record<string, any>
}

CanonicalOrderItem

export interface CanonicalOrderItem {
  name: string
  quantity: number
  unitPrice: number
  totalPrice: number
  vendorId?: string
}

CanonicalCustomer (temporary abstraction)

export interface CanonicalCustomer {
  email?: string
  phone?: string
  name?: string
  source: 'SVM' | 'MVM' | 'PARKHUB'
}


‚∏ª

2Ô∏è‚É£ Status Normalization (Mapping Only)

Create a status enum:

export enum CanonicalOrderStatus {
  CREATED,
  PENDING_PAYMENT,
  PAID,
  FULFILLED,
  CANCELLED,
  FAILED,
}

Implement pure mapping functions:
	‚Ä¢	SVM ‚Üí Canonical
	‚Ä¢	MVM ‚Üí Canonical
	‚Ä¢	ParkHub ‚Üí Canonical

‚ö†Ô∏è Do NOT attempt to ‚Äúcorrect‚Äù inconsistencies ‚Äî map exactly and document gaps.

‚∏ª

3Ô∏è‚É£ Resolver Functions (READ-ONLY)

Implement the following resolvers:

resolveSvmOrderToCanonical(orderId)
resolveMvmParentOrderToCanonical(orderId)
resolveParkTicketToCanonical(ticketId)

Rules:
	‚Ä¢	Prisma read-only queries only
	‚Ä¢	Must include tenantId verification
	‚Ä¢	Must throw 404 if order does not belong to tenant
	‚Ä¢	Must work for demo tenants

‚∏ª

4Ô∏è‚É£ CanonicalOrderService

Create:

frontend/src/lib/commerce/canonical-order/canonical-order-service.ts

Expose read-only APIs:

listByCustomerIdentifier({
  tenantId,
  email?,
  phone?
})

getByReference({
  tenantId,
  reference
})

Rules:
	‚Ä¢	Aggregate across SVM + MVM + ParkHub
	‚Ä¢	No pagination logic invention ‚Äî reuse simple limits
	‚Ä¢	No caching
	‚Ä¢	No background jobs

‚∏ª

5Ô∏è‚É£ Public Read-Only API Endpoints

Create:

GET /api/orders/canonical
GET /api/orders/canonical/[reference]

Security rules:
	‚Ä¢	Demo tenants: open access
	‚Ä¢	Live tenants: require tenantSlug resolution
	‚Ä¢	NO authentication system introduced
	‚Ä¢	NO mutation endpoints

‚∏ª

üßæ GAP DOCUMENTATION (MANDATORY)

Create a file:

frontend/WAVE_J1_GAPS.md

Document every gap encountered, including but not limited to:
	‚Ä¢	Inconsistent status enums
	‚Ä¢	Missing customer identifiers
	‚Ä¢	Missing receipt linkage
	‚Ä¢	ParkHub vs commerce structural differences
	‚Ä¢	Any ambiguity that required assumptions

üö® If a gap exists:
	‚Ä¢	DOCUMENT IT
	‚Ä¢	DO NOT SOLVE IT
	‚Ä¢	DO NOT WORK AROUND IT

‚∏ª

üß™ VERIFICATION REQUIREMENTS

Replit must verify:
	‚Ä¢	‚úÖ One SVM order resolves correctly
	‚Ä¢	‚úÖ One MVM parent order resolves correctly
	‚Ä¢	‚úÖ One ParkHub ticket resolves correctly
	‚Ä¢	‚úÖ Invalid tenant/order returns 404
	‚Ä¢	‚úÖ Demo tenant works without auth

‚∏ª

üõë STOP CONDITION

When finished:
	1.	Produce Wave J.1 Completion Report
	2.	Include:
	‚Ä¢	Files created
	‚Ä¢	APIs exposed
	‚Ä¢	Example canonical payloads
	‚Ä¢	Full gap list
	3.	STOP ‚Äî do not proceed to Wave J.2 without explicit approval

‚∏ª

üß† SUCCESS DEFINITION

Wave J.1 is successful if:
	‚Ä¢	A single API can return a mixed list of SVM, MVM, and ParkHub orders
	‚Ä¢	No existing logic was changed
	‚Ä¢	No schemas were touched
	‚Ä¢	All gaps are clearly documented
	‚Ä¢	The platform is now structurally ready for Wave J.2

‚∏ª

END OF EXECUTION PROMPT

Once Replit completes this, we will:
	1.	Review Wave J.1 gaps
	2.	Decide whether to proceed to Wave J.2 (Customer Identity) or adjust the abstraction first

You‚Äôre steering this exactly right.